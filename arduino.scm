;;;;
;;;; arduino.stk         -- ArduinoML en Scheme
;;;;
;;;;           Author: Erick Gallesio [eg@unice.fr]
;;;;    Creation date: 26-Oct-2017 17:16
;;;; Last file update:  1-Dec-2017 11:48 (eg)
;;;;

(define-macro (define-application names . clauses)

  ;; ======================================================================
  ;;                    Compatibility functions
  ;; ======================================================================

  (define keyword-get
    (cond-expand
     (stklos key-get)
     (gauche (lambda (lst key default) (get-keyword key lst default)))
     (else   (lambda (lst key default)
               (if (pair? lst)
                   (cond
                     ((null? (cdr lst))
                      (error "malformed list of keywords"))
                     ((eq? (car lst) key)
                      (cadr lst))
                     (else
                      (keyword-get (cddr lst) key default)))
                   default)))))
  (define print
    (cond-expand
     ((or guile gauche)    (lambda args (apply format #t args)))
     (else                printf)))

  ;; ======================================================================
  ;;                    Code generation
  ;; ======================================================================

  (define (generate-header)
    (print "// File generated by arduinoML (Scheme)\n\n")
    (print "long time = 0;\n")
    (print "long debounce = 200;\n\n"))

  (define (generate-globals bricks)
    (for-each (lambda (x)
                (print "int ~S = ~S;\n" (car x) (caddr x)))
              bricks)
    (print "\n"))

  (define (generate-setup bricks)
    (print "void setup() {\n")
    (for-each (lambda (x)
                (print "  pinMode(~S, ~A);\n"
                        (car x)
                        (if (eq? (cadr x) 'sensor) "INPUT" "OUTPUT")))
              bricks)
    (print "}\n\n"))

  (define (find-transition name transitions)
    (if (null? transitions)
        '()
        (if (eq? (caar transitions) name)
            (car transitions)
            (find-transition name (cdr transitions)))))

  (define (generate-actions actions)
    (for-each (lambda (action)
                (print "  digitalWrite(~A, ~A);\n" (cadr action) (caddr action)))
              actions))

  (define (generate-states states trans)
    (for-each (lambda (state)
                (let* ((name    (car state))
                       (actions (cdr state))
                       (trans   (find-transition name trans))
                       (from    (car trans))
                       (to      (caddr trans))
                       (when    (cddddr trans)))
                  (print "void state_~S() {\n" name)
                  (generate-actions actions)
                  (print "  boolean guard =  millis() - time > debounce;\n")
                  (print "  if (digitalRead(~A) == ~A  && guard) {\n"
                          (car when) (cadr when))
                  (print "    time = millis()\n")
                  (print "    state_~A();\n" to)
                  (print "  } else {\n")
                  (print "    state_~A();\n" from)
                  (print "  }\n")
                  (print "}\n\n")))
              states))

  (define (generate-loop initial)
    (print "void loop () {\n")
    (print "   state_~A();\n" initial)
    (print "}\n"))

  ;;;
  ;;; Macro body starts here
  ;;;

  (let ((bricks      (keyword-get clauses ':bricks '()))
        (states      (keyword-get clauses ':states '()))
        (transitions (keyword-get clauses ':transitions '()))
        (initial     (keyword-get clauses ':initial '())))
    (generate-header)
    (generate-globals bricks)
    (generate-setup   bricks)
    (generate-states  states transitions)
    (generate-loop    initial)))


